{"ast":null,"code":"import { API_VERSION_HEADER_NAME, BASE64URL_REGEX } from './constants';\nimport { AuthInvalidJwtError } from './errors';\nimport { base64UrlToUint8Array, stringFromBase64URL } from './base64url';\nexport function expiresAt(expiresIn) {\n  const timeNow = Math.round(Date.now() / 1000);\n  return timeNow + expiresIn;\n}\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = Math.random() * 16 | 0,\n      v = c == 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\nexport const isBrowser = () => typeof window !== 'undefined' && typeof document !== 'undefined';\nconst localStorageWriteTests = {\n  tested: false,\n  writable: false\n};\n/**\r\n * Checks whether localStorage is supported on this browser.\r\n */\nexport const supportsLocalStorage = () => {\n  if (!isBrowser()) {\n    return false;\n  }\n  try {\n    if (typeof globalThis.localStorage !== 'object') {\n      return false;\n    }\n  } catch (e) {\n    // DOM exception when accessing `localStorage`\n    return false;\n  }\n  if (localStorageWriteTests.tested) {\n    return localStorageWriteTests.writable;\n  }\n  const randomKey = \"lswt-\".concat(Math.random()).concat(Math.random());\n  try {\n    globalThis.localStorage.setItem(randomKey, randomKey);\n    globalThis.localStorage.removeItem(randomKey);\n    localStorageWriteTests.tested = true;\n    localStorageWriteTests.writable = true;\n  } catch (e) {\n    // localStorage can't be written to\n    // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n    localStorageWriteTests.tested = true;\n    localStorageWriteTests.writable = false;\n  }\n  return localStorageWriteTests.writable;\n};\n/**\r\n * Extracts parameters encoded in the URL both in the query and fragment.\r\n */\nexport function parseParametersFromURL(href) {\n  const result = {};\n  const url = new URL(href);\n  if (url.hash && url.hash[0] === '#') {\n    try {\n      const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n      hashSearchParams.forEach((value, key) => {\n        result[key] = value;\n      });\n    } catch (e) {\n      // hash is not a query string\n    }\n  }\n  // search parameters take precedence over hash parameters\n  url.searchParams.forEach((value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\nexport const resolveFetch = customFetch => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === 'undefined') {\n    _fetch = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return import('@supabase/node-fetch').then(_ref => {\n        let {\n          default: fetch\n        } = _ref;\n        return fetch(...args);\n      });\n    };\n  } else {\n    _fetch = fetch;\n  }\n  return function () {\n    return _fetch(...arguments);\n  };\n};\nexport const looksLikeFetchResponse = maybeResponse => {\n  return typeof maybeResponse === 'object' && maybeResponse !== null && 'status' in maybeResponse && 'ok' in maybeResponse && 'json' in maybeResponse && typeof maybeResponse.json === 'function';\n};\n// Storage helpers\nexport const setItemAsync = async (storage, key, data) => {\n  await storage.setItem(key, JSON.stringify(data));\n};\nexport const getItemAsync = async (storage, key) => {\n  const value = await storage.getItem(key);\n  if (!value) {\n    return null;\n  }\n  try {\n    return JSON.parse(value);\n  } catch (_a) {\n    return value;\n  }\n};\nexport const removeItemAsync = async (storage, key) => {\n  await storage.removeItem(key);\n};\n/**\r\n * A deferred represents some asynchronous work that is not yet finished, which\r\n * may or may not culminate in a value.\r\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\r\n */\nexport class Deferred {\n  constructor() {\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\n    ;\n    this.promise = new Deferred.promiseConstructor((res, rej) => {\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;\n      this.resolve = res;\n      this.reject = rej;\n    });\n  }\n}\nDeferred.promiseConstructor = Promise;\nexport function decodeJWT(token) {\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw new AuthInvalidJwtError('Invalid JWT structure');\n  }\n  // Regex checks for base64url format\n  for (let i = 0; i < parts.length; i++) {\n    if (!BASE64URL_REGEX.test(parts[i])) {\n      throw new AuthInvalidJwtError('JWT not in base64url format');\n    }\n  }\n  const data = {\n    // using base64url lib\n    header: JSON.parse(stringFromBase64URL(parts[0])),\n    payload: JSON.parse(stringFromBase64URL(parts[1])),\n    signature: base64UrlToUint8Array(parts[2]),\n    raw: {\n      header: parts[0],\n      payload: parts[1]\n    }\n  };\n  return data;\n}\n/**\r\n * Creates a promise that resolves to null after some time.\r\n */\nexport async function sleep(time) {\n  return await new Promise(accept => {\n    setTimeout(() => accept(null), time);\n  });\n}\n/**\r\n * Converts the provided async function into a retryable function. Each result\r\n * or thrown error is sent to the isRetryable function which should return true\r\n * if the function should run again.\r\n */\nexport function retryable(fn, isRetryable) {\n  const promise = new Promise((accept, reject) => {\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\n    ;\n    (async () => {\n      for (let attempt = 0; attempt < Infinity; attempt++) {\n        try {\n          const result = await fn(attempt);\n          if (!isRetryable(attempt, null, result)) {\n            accept(result);\n            return;\n          }\n        } catch (e) {\n          if (!isRetryable(attempt, e)) {\n            reject(e);\n            return;\n          }\n        }\n      }\n    })();\n  });\n  return promise;\n}\nfunction dec2hex(dec) {\n  return ('0' + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nexport function generatePKCEVerifier() {\n  const verifierLength = 56;\n  const array = new Uint32Array(verifierLength);\n  if (typeof crypto === 'undefined') {\n    const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n    const charSetLen = charSet.length;\n    let verifier = '';\n    for (let i = 0; i < verifierLength; i++) {\n      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n    }\n    return verifier;\n  }\n  crypto.getRandomValues(array);\n  return Array.from(array, dec2hex).join('');\n}\nasync function sha256(randomString) {\n  const encoder = new TextEncoder();\n  const encodedData = encoder.encode(randomString);\n  const hash = await crypto.subtle.digest('SHA-256', encodedData);\n  const bytes = new Uint8Array(hash);\n  return Array.from(bytes).map(c => String.fromCharCode(c)).join('');\n}\nexport async function generatePKCEChallenge(verifier) {\n  const hasCryptoSupport = typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined' && typeof TextEncoder !== 'undefined';\n  if (!hasCryptoSupport) {\n    console.warn('WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.');\n    return verifier;\n  }\n  const hashed = await sha256(verifier);\n  return btoa(hashed).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\nexport async function getCodeChallengeAndMethod(storage, storageKey) {\n  let isPasswordRecovery = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const codeVerifier = generatePKCEVerifier();\n  let storedCodeVerifier = codeVerifier;\n  if (isPasswordRecovery) {\n    storedCodeVerifier += '/PASSWORD_RECOVERY';\n  }\n  await setItemAsync(storage, \"\".concat(storageKey, \"-code-verifier\"), storedCodeVerifier);\n  const codeChallenge = await generatePKCEChallenge(codeVerifier);\n  const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n  return [codeChallenge, codeChallengeMethod];\n}\n/** Parses the API version which is 2YYY-MM-DD. */\nconst API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nexport function parseResponseAPIVersion(response) {\n  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);\n  if (!apiVersion) {\n    return null;\n  }\n  if (!apiVersion.match(API_VERSION_REGEX)) {\n    return null;\n  }\n  try {\n    const date = new Date(\"\".concat(apiVersion, \"T00:00:00.0Z\"));\n    return date;\n  } catch (e) {\n    return null;\n  }\n}\nexport function validateExp(exp) {\n  if (!exp) {\n    throw new Error('Missing exp claim');\n  }\n  const timeNow = Math.floor(Date.now() / 1000);\n  if (exp <= timeNow) {\n    throw new Error('JWT has expired');\n  }\n}\nexport function getAlgorithm(alg) {\n  switch (alg) {\n    case 'RS256':\n      return {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: {\n          name: 'SHA-256'\n        }\n      };\n    case 'ES256':\n      return {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n        hash: {\n          name: 'SHA-256'\n        }\n      };\n    default:\n      throw new Error('Invalid alg claim');\n  }\n}","map":{"version":3,"names":["API_VERSION_HEADER_NAME","BASE64URL_REGEX","AuthInvalidJwtError","base64UrlToUint8Array","stringFromBase64URL","expiresAt","expiresIn","timeNow","Math","round","Date","now","uuid","replace","c","r","random","v","toString","isBrowser","window","document","localStorageWriteTests","tested","writable","supportsLocalStorage","globalThis","localStorage","e","randomKey","concat","setItem","removeItem","parseParametersFromURL","href","result","url","URL","hash","hashSearchParams","URLSearchParams","substring","forEach","value","key","searchParams","resolveFetch","customFetch","_fetch","fetch","_len","arguments","length","args","Array","_key","then","_ref","default","looksLikeFetchResponse","maybeResponse","json","setItemAsync","storage","data","JSON","stringify","getItemAsync","getItem","parse","_a","removeItemAsync","Deferred","constructor","promise","promiseConstructor","res","rej","resolve","reject","Promise","decodeJWT","token","parts","split","i","test","header","payload","signature","raw","sleep","time","accept","setTimeout","retryable","fn","isRetryable","attempt","Infinity","dec2hex","dec","substr","generatePKCEVerifier","verifierLength","array","Uint32Array","crypto","charSet","charSetLen","verifier","charAt","floor","getRandomValues","from","join","sha256","randomString","encoder","TextEncoder","encodedData","encode","subtle","digest","bytes","Uint8Array","map","String","fromCharCode","generatePKCEChallenge","hasCryptoSupport","console","warn","hashed","btoa","getCodeChallengeAndMethod","storageKey","isPasswordRecovery","undefined","codeVerifier","storedCodeVerifier","codeChallenge","codeChallengeMethod","API_VERSION_REGEX","parseResponseAPIVersion","response","apiVersion","headers","get","match","date","validateExp","exp","Error","getAlgorithm","alg","name","namedCurve"],"sources":["C:\\VSCode\\clientcontactapp\\clientcontactapp\\node_modules\\@supabase\\auth-js\\src\\lib\\helpers.ts"],"sourcesContent":["import { API_VERSION_HEADER_NAME, BASE64URL_REGEX } from './constants'\r\nimport { AuthInvalidJwtError } from './errors'\r\nimport { base64UrlToUint8Array, stringFromBase64URL, stringToBase64URL } from './base64url'\r\nimport { JwtHeader, JwtPayload, SupportedStorage } from './types'\r\n\r\nexport function expiresAt(expiresIn: number) {\r\n  const timeNow = Math.round(Date.now() / 1000)\r\n  return timeNow + expiresIn\r\n}\r\n\r\nexport function uuid() {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n    const r = (Math.random() * 16) | 0,\r\n      v = c == 'x' ? r : (r & 0x3) | 0x8\r\n    return v.toString(16)\r\n  })\r\n}\r\n\r\nexport const isBrowser = () => typeof window !== 'undefined' && typeof document !== 'undefined'\r\n\r\nconst localStorageWriteTests = {\r\n  tested: false,\r\n  writable: false,\r\n}\r\n\r\n/**\r\n * Checks whether localStorage is supported on this browser.\r\n */\r\nexport const supportsLocalStorage = () => {\r\n  if (!isBrowser()) {\r\n    return false\r\n  }\r\n\r\n  try {\r\n    if (typeof globalThis.localStorage !== 'object') {\r\n      return false\r\n    }\r\n  } catch (e) {\r\n    // DOM exception when accessing `localStorage`\r\n    return false\r\n  }\r\n\r\n  if (localStorageWriteTests.tested) {\r\n    return localStorageWriteTests.writable\r\n  }\r\n\r\n  const randomKey = `lswt-${Math.random()}${Math.random()}`\r\n\r\n  try {\r\n    globalThis.localStorage.setItem(randomKey, randomKey)\r\n    globalThis.localStorage.removeItem(randomKey)\r\n\r\n    localStorageWriteTests.tested = true\r\n    localStorageWriteTests.writable = true\r\n  } catch (e) {\r\n    // localStorage can't be written to\r\n    // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\r\n\r\n    localStorageWriteTests.tested = true\r\n    localStorageWriteTests.writable = false\r\n  }\r\n\r\n  return localStorageWriteTests.writable\r\n}\r\n\r\n/**\r\n * Extracts parameters encoded in the URL both in the query and fragment.\r\n */\r\nexport function parseParametersFromURL(href: string) {\r\n  const result: { [parameter: string]: string } = {}\r\n\r\n  const url = new URL(href)\r\n\r\n  if (url.hash && url.hash[0] === '#') {\r\n    try {\r\n      const hashSearchParams = new URLSearchParams(url.hash.substring(1))\r\n      hashSearchParams.forEach((value, key) => {\r\n        result[key] = value\r\n      })\r\n    } catch (e: any) {\r\n      // hash is not a query string\r\n    }\r\n  }\r\n\r\n  // search parameters take precedence over hash parameters\r\n  url.searchParams.forEach((value, key) => {\r\n    result[key] = value\r\n  })\r\n\r\n  return result\r\n}\r\n\r\ntype Fetch = typeof fetch\r\n\r\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\r\n  let _fetch: Fetch\r\n  if (customFetch) {\r\n    _fetch = customFetch\r\n  } else if (typeof fetch === 'undefined') {\r\n    _fetch = (...args) =>\r\n      import('@supabase/node-fetch' as any).then(({ default: fetch }) => fetch(...args))\r\n  } else {\r\n    _fetch = fetch\r\n  }\r\n  return (...args) => _fetch(...args)\r\n}\r\n\r\nexport const looksLikeFetchResponse = (maybeResponse: unknown): maybeResponse is Response => {\r\n  return (\r\n    typeof maybeResponse === 'object' &&\r\n    maybeResponse !== null &&\r\n    'status' in maybeResponse &&\r\n    'ok' in maybeResponse &&\r\n    'json' in maybeResponse &&\r\n    typeof (maybeResponse as any).json === 'function'\r\n  )\r\n}\r\n\r\n// Storage helpers\r\nexport const setItemAsync = async (\r\n  storage: SupportedStorage,\r\n  key: string,\r\n  data: any\r\n): Promise<void> => {\r\n  await storage.setItem(key, JSON.stringify(data))\r\n}\r\n\r\nexport const getItemAsync = async (storage: SupportedStorage, key: string): Promise<unknown> => {\r\n  const value = await storage.getItem(key)\r\n\r\n  if (!value) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    return JSON.parse(value)\r\n  } catch {\r\n    return value\r\n  }\r\n}\r\n\r\nexport const removeItemAsync = async (storage: SupportedStorage, key: string): Promise<void> => {\r\n  await storage.removeItem(key)\r\n}\r\n\r\n/**\r\n * A deferred represents some asynchronous work that is not yet finished, which\r\n * may or may not culminate in a value.\r\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\r\n */\r\nexport class Deferred<T = any> {\r\n  public static promiseConstructor: PromiseConstructor = Promise\r\n\r\n  public readonly promise!: PromiseLike<T>\r\n\r\n  public readonly resolve!: (value?: T | PromiseLike<T>) => void\r\n\r\n  public readonly reject!: (reason?: any) => any\r\n\r\n  public constructor() {\r\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\r\n    ;(this as any).promise = new Deferred.promiseConstructor((res, rej) => {\r\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\r\n      ;(this as any).resolve = res\r\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\r\n      ;(this as any).reject = rej\r\n    })\r\n  }\r\n}\r\n\r\nexport function decodeJWT(token: string): {\r\n  header: JwtHeader\r\n  payload: JwtPayload\r\n  signature: Uint8Array\r\n  raw: {\r\n    header: string\r\n    payload: string\r\n  }\r\n} {\r\n  const parts = token.split('.')\r\n\r\n  if (parts.length !== 3) {\r\n    throw new AuthInvalidJwtError('Invalid JWT structure')\r\n  }\r\n\r\n  // Regex checks for base64url format\r\n  for (let i = 0; i < parts.length; i++) {\r\n    if (!BASE64URL_REGEX.test(parts[i] as string)) {\r\n      throw new AuthInvalidJwtError('JWT not in base64url format')\r\n    }\r\n  }\r\n  const data = {\r\n    // using base64url lib\r\n    header: JSON.parse(stringFromBase64URL(parts[0])),\r\n    payload: JSON.parse(stringFromBase64URL(parts[1])),\r\n    signature: base64UrlToUint8Array(parts[2]),\r\n    raw: {\r\n      header: parts[0],\r\n      payload: parts[1],\r\n    },\r\n  }\r\n  return data\r\n}\r\n\r\n/**\r\n * Creates a promise that resolves to null after some time.\r\n */\r\nexport async function sleep(time: number): Promise<null> {\r\n  return await new Promise((accept) => {\r\n    setTimeout(() => accept(null), time)\r\n  })\r\n}\r\n\r\n/**\r\n * Converts the provided async function into a retryable function. Each result\r\n * or thrown error is sent to the isRetryable function which should return true\r\n * if the function should run again.\r\n */\r\nexport function retryable<T>(\r\n  fn: (attempt: number) => Promise<T>,\r\n  isRetryable: (attempt: number, error: any | null, result?: T) => boolean\r\n): Promise<T> {\r\n  const promise = new Promise<T>((accept, reject) => {\r\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\r\n    ;(async () => {\r\n      for (let attempt = 0; attempt < Infinity; attempt++) {\r\n        try {\r\n          const result = await fn(attempt)\r\n\r\n          if (!isRetryable(attempt, null, result)) {\r\n            accept(result)\r\n            return\r\n          }\r\n        } catch (e: any) {\r\n          if (!isRetryable(attempt, e)) {\r\n            reject(e)\r\n            return\r\n          }\r\n        }\r\n      }\r\n    })()\r\n  })\r\n\r\n  return promise\r\n}\r\n\r\nfunction dec2hex(dec: number) {\r\n  return ('0' + dec.toString(16)).substr(-2)\r\n}\r\n\r\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\r\nexport function generatePKCEVerifier() {\r\n  const verifierLength = 56\r\n  const array = new Uint32Array(verifierLength)\r\n  if (typeof crypto === 'undefined') {\r\n    const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~'\r\n    const charSetLen = charSet.length\r\n    let verifier = ''\r\n    for (let i = 0; i < verifierLength; i++) {\r\n      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen))\r\n    }\r\n    return verifier\r\n  }\r\n  crypto.getRandomValues(array)\r\n  return Array.from(array, dec2hex).join('')\r\n}\r\n\r\nasync function sha256(randomString: string) {\r\n  const encoder = new TextEncoder()\r\n  const encodedData = encoder.encode(randomString)\r\n  const hash = await crypto.subtle.digest('SHA-256', encodedData)\r\n  const bytes = new Uint8Array(hash)\r\n\r\n  return Array.from(bytes)\r\n    .map((c) => String.fromCharCode(c))\r\n    .join('')\r\n}\r\n\r\nexport async function generatePKCEChallenge(verifier: string) {\r\n  const hasCryptoSupport =\r\n    typeof crypto !== 'undefined' &&\r\n    typeof crypto.subtle !== 'undefined' &&\r\n    typeof TextEncoder !== 'undefined'\r\n\r\n  if (!hasCryptoSupport) {\r\n    console.warn(\r\n      'WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.'\r\n    )\r\n    return verifier\r\n  }\r\n  const hashed = await sha256(verifier)\r\n  return btoa(hashed).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '')\r\n}\r\n\r\nexport async function getCodeChallengeAndMethod(\r\n  storage: SupportedStorage,\r\n  storageKey: string,\r\n  isPasswordRecovery = false\r\n) {\r\n  const codeVerifier = generatePKCEVerifier()\r\n  let storedCodeVerifier = codeVerifier\r\n  if (isPasswordRecovery) {\r\n    storedCodeVerifier += '/PASSWORD_RECOVERY'\r\n  }\r\n  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier)\r\n  const codeChallenge = await generatePKCEChallenge(codeVerifier)\r\n  const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\r\n  return [codeChallenge, codeChallengeMethod]\r\n}\r\n\r\n/** Parses the API version which is 2YYY-MM-DD. */\r\nconst API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i\r\n\r\nexport function parseResponseAPIVersion(response: Response) {\r\n  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME)\r\n\r\n  if (!apiVersion) {\r\n    return null\r\n  }\r\n\r\n  if (!apiVersion.match(API_VERSION_REGEX)) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    const date = new Date(`${apiVersion}T00:00:00.0Z`)\r\n    return date\r\n  } catch (e: any) {\r\n    return null\r\n  }\r\n}\r\n\r\nexport function validateExp(exp: number) {\r\n  if (!exp) {\r\n    throw new Error('Missing exp claim')\r\n  }\r\n  const timeNow = Math.floor(Date.now() / 1000)\r\n  if (exp <= timeNow) {\r\n    throw new Error('JWT has expired')\r\n  }\r\n}\r\n\r\nexport function getAlgorithm(alg: 'RS256' | 'ES256'): RsaHashedImportParams | EcKeyImportParams {\r\n  switch (alg) {\r\n    case 'RS256':\r\n      return {\r\n        name: 'RSASSA-PKCS1-v1_5',\r\n        hash: { name: 'SHA-256' },\r\n      }\r\n    case 'ES256':\r\n      return {\r\n        name: 'ECDSA',\r\n        namedCurve: 'P-256',\r\n        hash: { name: 'SHA-256' },\r\n      }\r\n    default:\r\n      throw new Error('Invalid alg claim')\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}