{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst PostgrestFilterBuilder_1 = __importDefault(require(\"./PostgrestFilterBuilder\"));\nclass PostgrestQueryBuilder {\n  constructor(url, {\n    headers = {},\n    schema,\n    fetch\n  }) {\n    this.url = url;\n    this.headers = headers;\n    this.schema = schema;\n    this.fetch = fetch;\n  }\n  /**\r\n   * Perform a SELECT query on the table or view.\r\n   *\r\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   *\r\n   * @param options.count - Count algorithm to use to count rows in the table or view.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\n  select(columns, {\n    head = false,\n    count\n  } = {}) {\n    const method = head ? 'HEAD' : 'GET';\n    // Remove whitespaces except when quoted\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {\n      if (/\\s/.test(c) && !quoted) {\n        return '';\n      }\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n      return c;\n    }).join('');\n    this.url.searchParams.set('select', cleanedColumns);\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`;\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\r\n   * Perform an INSERT into the table or view.\r\n   *\r\n   * By default, inserted rows are not returned. To return it, chain the call\r\n   * with `.select()`.\r\n   *\r\n   * @param values - The values to insert. Pass an object to insert a single row\r\n   * or an array to insert multiple rows.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count inserted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   *\r\n   * @param options.defaultToNull - Make missing fields default to `null`.\r\n   * Otherwise, use the default value for the column. Only applies for bulk\r\n   * inserts.\r\n   */\n  insert(values, {\n    count,\n    defaultToNull = true\n  } = {}) {\n    const method = 'POST';\n    const prefersHeaders = [];\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer']);\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default');\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\r\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\r\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\r\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\r\n   * exist, or if it does exist, perform an alternative action depending on\r\n   * `ignoreDuplicates`.\r\n   *\r\n   * By default, upserted rows are not returned. To return it, chain the call\r\n   * with `.select()`.\r\n   *\r\n   * @param values - The values to upsert with. Pass an object to upsert a\r\n   * single row or an array to upsert multiple rows.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\r\n   * duplicate rows are determined. Two rows are duplicates if all the\r\n   * `onConflict` columns are equal.\r\n   *\r\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\r\n   * `false`, duplicate rows are merged with existing rows.\r\n   *\r\n   * @param options.count - Count algorithm to use to count upserted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   *\r\n   * @param options.defaultToNull - Make missing fields default to `null`.\r\n   * Otherwise, use the default value for the column. This only applies when\r\n   * inserting new rows, not when merging with existing rows under\r\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\r\n   */\n  upsert(values, {\n    onConflict,\n    ignoreDuplicates = false,\n    count,\n    defaultToNull = true\n  } = {}) {\n    const method = 'POST';\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`];\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer']);\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default');\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\r\n   * Perform an UPDATE on the table or view.\r\n   *\r\n   * By default, updated rows are not returned. To return it, chain the call\r\n   * with `.select()` after filters.\r\n   *\r\n   * @param values - The values to update with\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count updated rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\n  update(values, {\n    count\n  } = {}) {\n    const method = 'PATCH';\n    const prefersHeaders = [];\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer']);\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\r\n   * Perform a DELETE on the table or view.\r\n   *\r\n   * By default, deleted rows are not returned. To return it, chain the call\r\n   * with `.select()` after filters.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count deleted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\n  delete({\n    count\n  } = {}) {\n    const method = 'DELETE';\n    const prefersHeaders = [];\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer']);\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n}\nexports.default = PostgrestQueryBuilder;","map":{"version":3,"names":["PostgrestFilterBuilder_1","__importDefault","require","PostgrestQueryBuilder","constructor","url","headers","schema","fetch","select","columns","head","count","method","quoted","cleanedColumns","split","map","c","test","join","searchParams","set","default","allowEmpty","insert","values","defaultToNull","prefersHeaders","push","Array","isArray","reduce","acc","x","concat","Object","keys","length","uniqueColumns","Set","column","body","upsert","onConflict","ignoreDuplicates","undefined","update","delete","unshift","exports"],"sources":["C:\\VSCode\\clientcontactapp\\clientcontactapp\\node_modules\\@supabase\\postgrest-js\\src\\PostgrestQueryBuilder.ts"],"sourcesContent":["import PostgrestBuilder from './PostgrestBuilder'\r\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\r\nimport { GetResult } from './select-query-parser/result'\r\nimport { Fetch, GenericSchema, GenericTable, GenericView } from './types'\r\n\r\nexport default class PostgrestQueryBuilder<\r\n  Schema extends GenericSchema,\r\n  Relation extends GenericTable | GenericView,\r\n  RelationName = unknown,\r\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown\r\n> {\r\n  url: URL\r\n  headers: Record<string, string>\r\n  schema?: string\r\n  signal?: AbortSignal\r\n  fetch?: Fetch\r\n\r\n  constructor(\r\n    url: URL,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      fetch,\r\n    }: {\r\n      headers?: Record<string, string>\r\n      schema?: string\r\n      fetch?: Fetch\r\n    }\r\n  ) {\r\n    this.url = url\r\n    this.headers = headers\r\n    this.schema = schema\r\n    this.fetch = fetch\r\n  }\r\n\r\n  /**\r\n   * Perform a SELECT query on the table or view.\r\n   *\r\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   *\r\n   * @param options.count - Count algorithm to use to count rows in the table or view.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  select<\r\n    Query extends string = '*',\r\n    ResultOne = GetResult<Schema, Relation['Row'], RelationName, Relationships, Query>\r\n  >(\r\n    columns?: Query,\r\n    {\r\n      head = false,\r\n      count,\r\n    }: {\r\n      head?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], ResultOne[], RelationName, Relationships> {\r\n    const method = head ? 'HEAD' : 'GET'\r\n    // Remove whitespaces except when quoted\r\n    let quoted = false\r\n    const cleanedColumns = (columns ?? '*')\r\n      .split('')\r\n      .map((c) => {\r\n        if (/\\s/.test(c) && !quoted) {\r\n          return ''\r\n        }\r\n        if (c === '\"') {\r\n          quoted = !quoted\r\n        }\r\n        return c\r\n      })\r\n      .join('')\r\n    this.url.searchParams.set('select', cleanedColumns)\r\n    if (count) {\r\n      this.headers['Prefer'] = `count=${count}`\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<ResultOne[]>)\r\n  }\r\n\r\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\r\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row,\r\n    options?: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    }\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\r\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row[],\r\n    options?: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    }\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\r\n  /**\r\n   * Perform an INSERT into the table or view.\r\n   *\r\n   * By default, inserted rows are not returned. To return it, chain the call\r\n   * with `.select()`.\r\n   *\r\n   * @param values - The values to insert. Pass an object to insert a single row\r\n   * or an array to insert multiple rows.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count inserted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   *\r\n   * @param options.defaultToNull - Make missing fields default to `null`.\r\n   * Otherwise, use the default value for the column. Only applies for bulk\r\n   * inserts.\r\n   */\r\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row | Row[],\r\n    {\r\n      count,\r\n      defaultToNull = true,\r\n    }: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\r\n    const method = 'POST'\r\n\r\n    const prefersHeaders = []\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.push(this.headers['Prefer'])\r\n    }\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (!defaultToNull) {\r\n      prefersHeaders.push('missing=default')\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    if (Array.isArray(values)) {\r\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\r\n      if (columns.length > 0) {\r\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\r\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\r\n      }\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      body: values,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n\r\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\r\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row,\r\n    options?: {\r\n      onConflict?: string\r\n      ignoreDuplicates?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    }\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\r\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row[],\r\n    options?: {\r\n      onConflict?: string\r\n      ignoreDuplicates?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    }\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\r\n  /**\r\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\r\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\r\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\r\n   * exist, or if it does exist, perform an alternative action depending on\r\n   * `ignoreDuplicates`.\r\n   *\r\n   * By default, upserted rows are not returned. To return it, chain the call\r\n   * with `.select()`.\r\n   *\r\n   * @param values - The values to upsert with. Pass an object to upsert a\r\n   * single row or an array to upsert multiple rows.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\r\n   * duplicate rows are determined. Two rows are duplicates if all the\r\n   * `onConflict` columns are equal.\r\n   *\r\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\r\n   * `false`, duplicate rows are merged with existing rows.\r\n   *\r\n   * @param options.count - Count algorithm to use to count upserted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   *\r\n   * @param options.defaultToNull - Make missing fields default to `null`.\r\n   * Otherwise, use the default value for the column. This only applies when\r\n   * inserting new rows, not when merging with existing rows under\r\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\r\n   */\r\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row | Row[],\r\n    {\r\n      onConflict,\r\n      ignoreDuplicates = false,\r\n      count,\r\n      defaultToNull = true,\r\n    }: {\r\n      onConflict?: string\r\n      ignoreDuplicates?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\r\n    const method = 'POST'\r\n\r\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`]\r\n\r\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.push(this.headers['Prefer'])\r\n    }\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (!defaultToNull) {\r\n      prefersHeaders.push('missing=default')\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    if (Array.isArray(values)) {\r\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\r\n      if (columns.length > 0) {\r\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\r\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\r\n      }\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      body: values,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n\r\n  /**\r\n   * Perform an UPDATE on the table or view.\r\n   *\r\n   * By default, updated rows are not returned. To return it, chain the call\r\n   * with `.select()` after filters.\r\n   *\r\n   * @param values - The values to update with\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count updated rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\r\n    values: Row,\r\n    {\r\n      count,\r\n    }: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\r\n    const method = 'PATCH'\r\n    const prefersHeaders = []\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.push(this.headers['Prefer'])\r\n    }\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      body: values,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n\r\n  /**\r\n   * Perform a DELETE on the table or view.\r\n   *\r\n   * By default, deleted rows are not returned. To return it, chain the call\r\n   * with `.select()` after filters.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count deleted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  delete({\r\n    count,\r\n  }: {\r\n    count?: 'exact' | 'planned' | 'estimated'\r\n  } = {}): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\r\n    const method = 'DELETE'\r\n    const prefersHeaders = []\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.unshift(this.headers['Prefer'])\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}