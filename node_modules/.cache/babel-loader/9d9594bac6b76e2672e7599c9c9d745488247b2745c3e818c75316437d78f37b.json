{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst PostgrestTransformBuilder_1 = __importDefault(require(\"./PostgrestTransformBuilder\"));\nclass PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {\n  /**\r\n   * Match only rows where `column` is equal to `value`.\r\n   *\r\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  eq(column, value) {\n    this.url.searchParams.append(column, \"eq.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is not equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  neq(column, value) {\n    this.url.searchParams.append(column, \"neq.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is greater than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  gt(column, value) {\n    this.url.searchParams.append(column, \"gt.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is greater than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  gte(column, value) {\n    this.url.searchParams.append(column, \"gte.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is less than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  lt(column, value) {\n    this.url.searchParams.append(column, \"lt.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is less than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  lte(column, value) {\n    this.url.searchParams.append(column, \"lte.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches `pattern` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\n  like(column, pattern) {\n    this.url.searchParams.append(column, \"like.\".concat(pattern));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  likeAllOf(column, patterns) {\n    this.url.searchParams.append(column, \"like(all).{\".concat(patterns.join(','), \"}\"));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  likeAnyOf(column, patterns) {\n    this.url.searchParams.append(column, \"like(any).{\".concat(patterns.join(','), \"}\"));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches `pattern` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\n  ilike(column, pattern) {\n    this.url.searchParams.append(column, \"ilike.\".concat(pattern));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  ilikeAllOf(column, patterns) {\n    this.url.searchParams.append(column, \"ilike(all).{\".concat(patterns.join(','), \"}\"));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  ilikeAnyOf(column, patterns) {\n    this.url.searchParams.append(column, \"ilike(any).{\".concat(patterns.join(','), \"}\"));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` IS `value`.\r\n   *\r\n   * For non-boolean columns, this is only relevant for checking if the value of\r\n   * `column` is NULL by setting `value` to `null`.\r\n   *\r\n   * For boolean columns, you can also set `value` to `true` or `false` and it\r\n   * will behave the same way as `.eq()`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  is(column, value) {\n    this.url.searchParams.append(column, \"is.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is included in the `values` array.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param values - The values array to filter with\r\n   */\n  in(column, values) {\n    const cleanedValues = Array.from(new Set(values)).map(s => {\n      // handle postgrest reserved characters\n      // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n      if (typeof s === 'string' && new RegExp('[,()]').test(s)) return \"\\\"\".concat(s, \"\\\"\");else return \"\".concat(s);\n    }).join(',');\n    this.url.searchParams.append(column, \"in.(\".concat(cleanedValues, \")\"));\n    return this;\n  }\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * `column` contains every element appearing in `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\n  contains(column, value) {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, \"cs.\".concat(value));\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, \"cs.{\".concat(value.join(','), \"}\"));\n    } else {\n      // json\n      this.url.searchParams.append(column, \"cs.\".concat(JSON.stringify(value)));\n    }\n    return this;\n  }\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * every element appearing in `column` is contained by `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\n  containedBy(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, \"cd.\".concat(value));\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, \"cd.{\".concat(value.join(','), \"}\"));\n    } else {\n      // json\n      this.url.searchParams.append(column, \"cd.\".concat(JSON.stringify(value)));\n    }\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is greater than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeGt(column, range) {\n    this.url.searchParams.append(column, \"sr.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or greater than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeGte(column, range) {\n    this.url.searchParams.append(column, \"nxl.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is less than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeLt(column, range) {\n    this.url.searchParams.append(column, \"sl.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or less than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeLte(column, range) {\n    this.url.searchParams.append(column, \"nxr.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where `column` is\r\n   * mutually exclusive to `range` and there can be no element between the two\r\n   * ranges.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeAdjacent(column, range) {\n    this.url.searchParams.append(column, \"adj.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for array and range columns. Match only rows where\r\n   * `column` and `value` have an element in common.\r\n   *\r\n   * @param column - The array or range column to filter on\r\n   * @param value - The array or range value to filter with\r\n   */\n  overlaps(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, \"ov.\".concat(value));\n    } else {\n      // array\n      this.url.searchParams.append(column, \"ov.{\".concat(value.join(','), \"}\"));\n    }\n    return this;\n  }\n  /**\r\n   * Only relevant for text and tsvector columns. Match only rows where\r\n   * `column` matches the query string in `query`.\r\n   *\r\n   * @param column - The text or tsvector column to filter on\r\n   * @param query - The query text to match with\r\n   * @param options - Named parameters\r\n   * @param options.config - The text search configuration to use\r\n   * @param options.type - Change how the `query` text is interpreted\r\n   */\n  textSearch(column, query) {\n    let {\n      config,\n      type\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let typePart = '';\n    if (type === 'plain') {\n      typePart = 'pl';\n    } else if (type === 'phrase') {\n      typePart = 'ph';\n    } else if (type === 'websearch') {\n      typePart = 'w';\n    }\n    const configPart = config === undefined ? '' : \"(\".concat(config, \")\");\n    this.url.searchParams.append(column, \"\".concat(typePart, \"fts\").concat(configPart, \".\").concat(query));\n    return this;\n  }\n  /**\r\n   * Match only rows where each column in `query` keys is equal to its\r\n   * associated value. Shorthand for multiple `.eq()`s.\r\n   *\r\n   * @param query - The object to filter with, with column names as keys mapped\r\n   * to their filter values\r\n   */\n  match(query) {\n    Object.entries(query).forEach(_ref => {\n      let [column, value] = _ref;\n      this.url.searchParams.append(column, \"eq.\".concat(value));\n    });\n    return this;\n  }\n  /**\r\n   * Match only rows which doesn't satisfy the filter.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to be negated to filter with, following\r\n   * PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\n  not(column, operator, value) {\n    this.url.searchParams.append(column, \"not.\".concat(operator, \".\").concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows which satisfy at least one of the filters.\r\n   *\r\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure it's properly sanitized.\r\n   *\r\n   * It's currently not possible to do an `.or()` filter across multiple tables.\r\n   *\r\n   * @param filters - The filters to use, following PostgREST syntax\r\n   * @param options - Named parameters\r\n   * @param options.referencedTable - Set this to filter on referenced tables\r\n   * instead of the parent table\r\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\r\n   */\n  or(filters) {\n    let {\n      foreignTable,\n      referencedTable = foreignTable\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const key = referencedTable ? \"\".concat(referencedTable, \".or\") : 'or';\n    this.url.searchParams.append(key, \"(\".concat(filters, \")\"));\n    return this;\n  }\n  /**\r\n   * Match only rows which satisfy the filter. This is an escape hatch - you\r\n   * should use the specific filter methods wherever possible.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to filter with, following PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\n  filter(column, operator, value) {\n    this.url.searchParams.append(column, \"\".concat(operator, \".\").concat(value));\n    return this;\n  }\n}\nexports.default = PostgrestFilterBuilder;","map":{"version":3,"names":["PostgrestTransformBuilder_1","__importDefault","require","PostgrestFilterBuilder","default","eq","column","value","url","searchParams","append","concat","neq","gt","gte","lt","lte","like","pattern","likeAllOf","patterns","join","likeAnyOf","ilike","ilikeAllOf","ilikeAnyOf","is","in","values","cleanedValues","Array","from","Set","map","s","RegExp","test","contains","isArray","JSON","stringify","containedBy","rangeGt","range","rangeGte","rangeLt","rangeLte","rangeAdjacent","overlaps","textSearch","query","config","type","arguments","length","undefined","typePart","configPart","match","Object","entries","forEach","_ref","not","operator","or","filters","foreignTable","referencedTable","key","filter","exports"],"sources":["C:\\VSCode\\clientcontactapp\\clientcontactapp\\node_modules\\@supabase\\postgrest-js\\src\\PostgrestFilterBuilder.ts"],"sourcesContent":["import PostgrestTransformBuilder from './PostgrestTransformBuilder'\r\nimport { JsonPathToAccessor, JsonPathToType } from './select-query-parser/utils'\r\nimport { GenericSchema } from './types'\r\n\r\ntype FilterOperator =\r\n  | 'eq'\r\n  | 'neq'\r\n  | 'gt'\r\n  | 'gte'\r\n  | 'lt'\r\n  | 'lte'\r\n  | 'like'\r\n  | 'ilike'\r\n  | 'is'\r\n  | 'in'\r\n  | 'cs'\r\n  | 'cd'\r\n  | 'sl'\r\n  | 'sr'\r\n  | 'nxl'\r\n  | 'nxr'\r\n  | 'adj'\r\n  | 'ov'\r\n  | 'fts'\r\n  | 'plfts'\r\n  | 'phfts'\r\n  | 'wfts'\r\n\r\nexport type IsStringOperator<Path extends string> = Path extends `${string}->>${string}`\r\n  ? true\r\n  : false\r\n\r\n// Match relationship filters with `table.column` syntax and resolve underlying\r\n// column value. If not matched, fallback to generic type.\r\n// TODO: Validate the relationship itself ala select-query-parser. Currently we\r\n// assume that all tables have valid relationships to each other, despite\r\n// nonexistent foreign keys.\r\ntype ResolveFilterValue<\r\n  Schema extends GenericSchema,\r\n  Row extends Record<string, unknown>,\r\n  ColumnName extends string\r\n> = ColumnName extends `${infer RelationshipTable}.${infer Remainder}`\r\n  ? Remainder extends `${infer _}.${infer _}`\r\n    ? ResolveFilterValue<Schema, Row, Remainder>\r\n    : ResolveFilterRelationshipValue<Schema, RelationshipTable, Remainder>\r\n  : ColumnName extends keyof Row\r\n  ? Row[ColumnName]\r\n  : // If the column selection is a jsonpath like `data->value` or `data->>value` we attempt to match\r\n  // the expected type with the parsed custom json type\r\n  IsStringOperator<ColumnName> extends true\r\n  ? string\r\n  : JsonPathToType<Row, JsonPathToAccessor<ColumnName>> extends infer JsonPathValue\r\n  ? JsonPathValue extends never\r\n    ? never\r\n    : JsonPathValue\r\n  : never\r\n\r\ntype ResolveFilterRelationshipValue<\r\n  Schema extends GenericSchema,\r\n  RelationshipTable extends string,\r\n  RelationshipColumn extends string\r\n> = Schema['Tables'] & Schema['Views'] extends infer TablesAndViews\r\n  ? RelationshipTable extends keyof TablesAndViews\r\n    ? 'Row' extends keyof TablesAndViews[RelationshipTable]\r\n      ? RelationshipColumn extends keyof TablesAndViews[RelationshipTable]['Row']\r\n        ? TablesAndViews[RelationshipTable]['Row'][RelationshipColumn]\r\n        : unknown\r\n      : unknown\r\n    : unknown\r\n  : never\r\n\r\nexport default class PostgrestFilterBuilder<\r\n  Schema extends GenericSchema,\r\n  Row extends Record<string, unknown>,\r\n  Result,\r\n  RelationName = unknown,\r\n  Relationships = unknown\r\n> extends PostgrestTransformBuilder<Schema, Row, Result, RelationName, Relationships> {\r\n  /**\r\n   * Match only rows where `column` is equal to `value`.\r\n   *\r\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  eq<ColumnName extends string>(\r\n    column: ColumnName,\r\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\r\n      ? NonNullable<unknown>\r\n      : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\r\n      // type resolution error\r\n      ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\r\n      ? NonNullable<ResolvedFilterValue>\r\n      : // We should never enter this case as all the branches are covered above\r\n        never\r\n  ): this {\r\n    this.url.searchParams.append(column, `eq.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Match only rows where `column` is not equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  neq<ColumnName extends string>(\r\n    column: ColumnName,\r\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\r\n      ? unknown\r\n      : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\r\n      ? ResolvedFilterValue\r\n      : never\r\n  ): this {\r\n    this.url.searchParams.append(column, `neq.${value}`)\r\n    return this\r\n  }\r\n\r\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  gt(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is greater than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  gt(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `gt.${value}`)\r\n    return this\r\n  }\r\n\r\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  gte(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is greater than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  gte(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `gte.${value}`)\r\n    return this\r\n  }\r\n\r\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  lt(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is less than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  lt(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `lt.${value}`)\r\n    return this\r\n  }\r\n\r\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  lte(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is less than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  lte(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `lte.${value}`)\r\n    return this\r\n  }\r\n\r\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\r\n  like(column: string, pattern: string): this\r\n  /**\r\n   * Match only rows where `column` matches `pattern` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\r\n  like(column: string, pattern: string): this {\r\n    this.url.searchParams.append(column, `like.${pattern}`)\r\n    return this\r\n  }\r\n\r\n  likeAllOf<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    patterns: readonly string[]\r\n  ): this\r\n  likeAllOf(column: string, patterns: readonly string[]): this\r\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\r\n  likeAllOf(column: string, patterns: readonly string[]): this {\r\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\r\n    return this\r\n  }\r\n\r\n  likeAnyOf<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    patterns: readonly string[]\r\n  ): this\r\n  likeAnyOf(column: string, patterns: readonly string[]): this\r\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\r\n  likeAnyOf(column: string, patterns: readonly string[]): this {\r\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\r\n    return this\r\n  }\r\n\r\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\r\n  ilike(column: string, pattern: string): this\r\n  /**\r\n   * Match only rows where `column` matches `pattern` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\r\n  ilike(column: string, pattern: string): this {\r\n    this.url.searchParams.append(column, `ilike.${pattern}`)\r\n    return this\r\n  }\r\n\r\n  ilikeAllOf<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    patterns: readonly string[]\r\n  ): this\r\n  ilikeAllOf(column: string, patterns: readonly string[]): this\r\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\r\n  ilikeAllOf(column: string, patterns: readonly string[]): this {\r\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\r\n    return this\r\n  }\r\n\r\n  ilikeAnyOf<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    patterns: readonly string[]\r\n  ): this\r\n  ilikeAnyOf(column: string, patterns: readonly string[]): this\r\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\r\n  ilikeAnyOf(column: string, patterns: readonly string[]): this {\r\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\r\n    return this\r\n  }\r\n\r\n  is<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: Row[ColumnName] & (boolean | null)\r\n  ): this\r\n  is(column: string, value: boolean | null): this\r\n  /**\r\n   * Match only rows where `column` IS `value`.\r\n   *\r\n   * For non-boolean columns, this is only relevant for checking if the value of\r\n   * `column` is NULL by setting `value` to `null`.\r\n   *\r\n   * For boolean columns, you can also set `value` to `true` or `false` and it\r\n   * will behave the same way as `.eq()`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  is(column: string, value: boolean | null): this {\r\n    this.url.searchParams.append(column, `is.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Match only rows where `column` is included in the `values` array.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param values - The values array to filter with\r\n   */\r\n  in<ColumnName extends string>(\r\n    column: ColumnName,\r\n    values: ReadonlyArray<\r\n      ResolveFilterValue<Schema, Row, ColumnName> extends never\r\n        ? unknown\r\n        : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\r\n        // type resolution error\r\n        ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\r\n        ? ResolvedFilterValue\r\n        : // We should never enter this case as all the branches are covered above\r\n          never\r\n    >\r\n  ): this {\r\n    const cleanedValues = Array.from(new Set(values))\r\n      .map((s) => {\r\n        // handle postgrest reserved characters\r\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\r\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\r\n        else return `${s}`\r\n      })\r\n      .join(',')\r\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\r\n    return this\r\n  }\r\n\r\n  contains<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\r\n  ): this\r\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\r\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * `column` contains every element appearing in `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\r\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\r\n    if (typeof value === 'string') {\r\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\r\n      // keep it simple and accept a string\r\n      this.url.searchParams.append(column, `cs.${value}`)\r\n    } else if (Array.isArray(value)) {\r\n      // array\r\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\r\n    } else {\r\n      // json\r\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  containedBy<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\r\n  ): this\r\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\r\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * every element appearing in `column` is contained by `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\r\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\r\n    if (typeof value === 'string') {\r\n      // range\r\n      this.url.searchParams.append(column, `cd.${value}`)\r\n    } else if (Array.isArray(value)) {\r\n      // array\r\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\r\n    } else {\r\n      // json\r\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeGt(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is greater than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeGt(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `sr.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeGte(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or greater than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeGte(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `nxl.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeLt(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is less than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeLt(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `sl.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeLte(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or less than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeLte(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `nxr.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeAdjacent(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where `column` is\r\n   * mutually exclusive to `range` and there can be no element between the two\r\n   * ranges.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeAdjacent(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `adj.${range}`)\r\n    return this\r\n  }\r\n\r\n  overlaps<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: string | ReadonlyArray<Row[ColumnName]>\r\n  ): this\r\n  overlaps(column: string, value: string | readonly unknown[]): this\r\n  /**\r\n   * Only relevant for array and range columns. Match only rows where\r\n   * `column` and `value` have an element in common.\r\n   *\r\n   * @param column - The array or range column to filter on\r\n   * @param value - The array or range value to filter with\r\n   */\r\n  overlaps(column: string, value: string | readonly unknown[]): this {\r\n    if (typeof value === 'string') {\r\n      // range\r\n      this.url.searchParams.append(column, `ov.${value}`)\r\n    } else {\r\n      // array\r\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  textSearch<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    query: string,\r\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\r\n  ): this\r\n  textSearch(\r\n    column: string,\r\n    query: string,\r\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\r\n  ): this\r\n  /**\r\n   * Only relevant for text and tsvector columns. Match only rows where\r\n   * `column` matches the query string in `query`.\r\n   *\r\n   * @param column - The text or tsvector column to filter on\r\n   * @param query - The query text to match with\r\n   * @param options - Named parameters\r\n   * @param options.config - The text search configuration to use\r\n   * @param options.type - Change how the `query` text is interpreted\r\n   */\r\n  textSearch(\r\n    column: string,\r\n    query: string,\r\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\r\n  ): this {\r\n    let typePart = ''\r\n    if (type === 'plain') {\r\n      typePart = 'pl'\r\n    } else if (type === 'phrase') {\r\n      typePart = 'ph'\r\n    } else if (type === 'websearch') {\r\n      typePart = 'w'\r\n    }\r\n    const configPart = config === undefined ? '' : `(${config})`\r\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\r\n    return this\r\n  }\r\n\r\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\r\n  match(query: Record<string, unknown>): this\r\n  /**\r\n   * Match only rows where each column in `query` keys is equal to its\r\n   * associated value. Shorthand for multiple `.eq()`s.\r\n   *\r\n   * @param query - The object to filter with, with column names as keys mapped\r\n   * to their filter values\r\n   */\r\n  match(query: Record<string, unknown>): this {\r\n    Object.entries(query).forEach(([column, value]) => {\r\n      this.url.searchParams.append(column, `eq.${value}`)\r\n    })\r\n    return this\r\n  }\r\n\r\n  not<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    operator: FilterOperator,\r\n    value: Row[ColumnName]\r\n  ): this\r\n  not(column: string, operator: string, value: unknown): this\r\n  /**\r\n   * Match only rows which doesn't satisfy the filter.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to be negated to filter with, following\r\n   * PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\r\n  not(column: string, operator: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Match only rows which satisfy at least one of the filters.\r\n   *\r\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure it's properly sanitized.\r\n   *\r\n   * It's currently not possible to do an `.or()` filter across multiple tables.\r\n   *\r\n   * @param filters - The filters to use, following PostgREST syntax\r\n   * @param options - Named parameters\r\n   * @param options.referencedTable - Set this to filter on referenced tables\r\n   * instead of the parent table\r\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\r\n   */\r\n  or(\r\n    filters: string,\r\n    {\r\n      foreignTable,\r\n      referencedTable = foreignTable,\r\n    }: { foreignTable?: string; referencedTable?: string } = {}\r\n  ): this {\r\n    const key = referencedTable ? `${referencedTable}.or` : 'or'\r\n    this.url.searchParams.append(key, `(${filters})`)\r\n    return this\r\n  }\r\n\r\n  filter<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    operator: `${'' | 'not.'}${FilterOperator}`,\r\n    value: unknown\r\n  ): this\r\n  filter(column: string, operator: string, value: unknown): this\r\n  /**\r\n   * Match only rows which satisfy the filter. This is an escape hatch - you\r\n   * should use the specific filter methods wherever possible.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to filter with, following PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\r\n  filter(column: string, operator: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `${operator}.${value}`)\r\n    return this\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}