{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:\\VSCode\\clientcontactapp\\clientcontactapp\\node_modules\\@supabase\\auth-js\\src\\lib\\types.ts"],"sourcesContent":["import { AuthError } from './errors'\r\nimport { Fetch } from './fetch'\r\n\r\n/** One of the providers supported by GoTrue. */\r\nexport type Provider =\r\n  | 'apple'\r\n  | 'azure'\r\n  | 'bitbucket'\r\n  | 'discord'\r\n  | 'facebook'\r\n  | 'figma'\r\n  | 'github'\r\n  | 'gitlab'\r\n  | 'google'\r\n  | 'kakao'\r\n  | 'keycloak'\r\n  | 'linkedin'\r\n  | 'linkedin_oidc'\r\n  | 'notion'\r\n  | 'slack'\r\n  | 'slack_oidc'\r\n  | 'spotify'\r\n  | 'twitch'\r\n  | 'twitter'\r\n  | 'workos'\r\n  | 'zoom'\r\n  | 'fly'\r\n\r\nexport type AuthChangeEventMFA = 'MFA_CHALLENGE_VERIFIED'\r\n\r\nexport type AuthChangeEvent =\r\n  | 'INITIAL_SESSION'\r\n  | 'PASSWORD_RECOVERY'\r\n  | 'SIGNED_IN'\r\n  | 'SIGNED_OUT'\r\n  | 'TOKEN_REFRESHED'\r\n  | 'USER_UPDATED'\r\n  | AuthChangeEventMFA\r\n\r\n/**\r\n * Provide your own global lock implementation instead of the default\r\n * implementation. The function should acquire a lock for the duration of the\r\n * `fn` async function, such that no other client instances will be able to\r\n * hold it at the same time.\r\n *\r\n * @experimental\r\n *\r\n * @param name Name of the lock to be acquired.\r\n * @param acquireTimeout If negative, no timeout should occur. If positive it\r\n *                       should throw an Error with an `isAcquireTimeout`\r\n *                       property set to true if the operation fails to be\r\n *                       acquired after this much time (ms).\r\n * @param fn The operation to execute when the lock is acquired.\r\n */\r\nexport type LockFunc = <R>(name: string, acquireTimeout: number, fn: () => Promise<R>) => Promise<R>\r\n\r\nexport type GoTrueClientOptions = {\r\n  /* The URL of the GoTrue server. */\r\n  url?: string\r\n  /* Any additional headers to send to the GoTrue server. */\r\n  headers?: { [key: string]: string }\r\n  /* Optional key name used for storing tokens in local storage. */\r\n  storageKey?: string\r\n  /* Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user. */\r\n  detectSessionInUrl?: boolean\r\n  /* Set to \"true\" if you want to automatically refresh the token before expiring. */\r\n  autoRefreshToken?: boolean\r\n  /* Set to \"true\" if you want to automatically save the user session into local storage. If set to false, session will just be saved in memory. */\r\n  persistSession?: boolean\r\n  /* Provide your own local storage implementation to use instead of the browser's local storage. */\r\n  storage?: SupportedStorage\r\n  /* A custom fetch implementation. */\r\n  fetch?: Fetch\r\n  /* If set to 'pkce' PKCE flow. Defaults to the 'implicit' flow otherwise */\r\n  flowType?: AuthFlowType\r\n  /* If debug messages are emitted. Can be used to inspect the behavior of the library. If set to a function, the provided function will be used instead of `console.log()` to perform the logging. */\r\n  debug?: boolean | ((message: string, ...args: any[]) => void)\r\n  /**\r\n   * Provide your own locking mechanism based on the environment. By default no locking is done at this time.\r\n   *\r\n   * @experimental\r\n   */\r\n  lock?: LockFunc\r\n  /**\r\n   * Set to \"true\" if there is a custom authorization header set globally.\r\n   * @experimental\r\n   */\r\n  hasCustomAuthorizationHeader?: boolean\r\n}\r\n\r\nexport type WeakPasswordReasons = 'length' | 'characters' | 'pwned' | (string & {})\r\nexport type WeakPassword = {\r\n  reasons: WeakPasswordReasons[]\r\n  message: string\r\n}\r\n\r\nexport type AuthResponse =\r\n  | {\r\n      data: {\r\n        user: User | null\r\n        session: Session | null\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: {\r\n        user: null\r\n        session: null\r\n      }\r\n      error: AuthError\r\n    }\r\n\r\nexport type AuthResponsePassword =\r\n  | {\r\n      data: {\r\n        user: User | null\r\n        session: Session | null\r\n        weak_password?: WeakPassword | null\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: {\r\n        user: null\r\n        session: null\r\n      }\r\n      error: AuthError\r\n    }\r\n\r\n/**\r\n * AuthOtpResponse is returned when OTP is used.\r\n *\r\n * {@see AuthResponse}\r\n */\r\nexport type AuthOtpResponse =\r\n  | {\r\n      data: { user: null; session: null; messageId?: string | null }\r\n      error: null\r\n    }\r\n  | {\r\n      data: { user: null; session: null; messageId?: string | null }\r\n      error: AuthError\r\n    }\r\n\r\nexport type AuthTokenResponse =\r\n  | {\r\n      data: {\r\n        user: User\r\n        session: Session\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: {\r\n        user: null\r\n        session: null\r\n      }\r\n      error: AuthError\r\n    }\r\n\r\nexport type AuthTokenResponsePassword =\r\n  | {\r\n      data: {\r\n        user: User\r\n        session: Session\r\n        weakPassword?: WeakPassword\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: {\r\n        user: null\r\n        session: null\r\n        weakPassword?: null\r\n      }\r\n      error: AuthError\r\n    }\r\n\r\nexport type OAuthResponse =\r\n  | {\r\n      data: {\r\n        provider: Provider\r\n        url: string\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: {\r\n        provider: Provider\r\n        url: null\r\n      }\r\n      error: AuthError\r\n    }\r\n\r\nexport type SSOResponse =\r\n  | {\r\n      data: {\r\n        /**\r\n         * URL to open in a browser which will complete the sign-in flow by\r\n         * taking the user to the identity provider's authentication flow.\r\n         *\r\n         * On browsers you can set the URL to `window.location.href` to take\r\n         * the user to the authentication flow.\r\n         */\r\n        url: string\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: null\r\n      error: AuthError\r\n    }\r\n\r\nexport type UserResponse =\r\n  | {\r\n      data: {\r\n        user: User\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: {\r\n        user: null\r\n      }\r\n      error: AuthError\r\n    }\r\n\r\nexport interface Session {\r\n  /**\r\n   * The oauth provider token. If present, this can be used to make external API requests to the oauth provider used.\r\n   */\r\n  provider_token?: string | null\r\n  /**\r\n   * The oauth provider refresh token. If present, this can be used to refresh the provider_token via the oauth provider's API.\r\n   * Not all oauth providers return a provider refresh token. If the provider_refresh_token is missing, please refer to the oauth provider's documentation for information on how to obtain the provider refresh token.\r\n   */\r\n  provider_refresh_token?: string | null\r\n  /**\r\n   * The access token jwt. It is recommended to set the JWT_EXPIRY to a shorter expiry value.\r\n   */\r\n  access_token: string\r\n  /**\r\n   * A one-time used refresh token that never expires.\r\n   */\r\n  refresh_token: string\r\n  /**\r\n   * The number of seconds until the token expires (since it was issued). Returned when a login is confirmed.\r\n   */\r\n  expires_in: number\r\n  /**\r\n   * A timestamp of when the token will expire. Returned when a login is confirmed.\r\n   */\r\n  expires_at?: number\r\n  token_type: string\r\n  user: User\r\n}\r\n\r\n/**\r\n * An authentication methord reference (AMR) entry.\r\n *\r\n * An entry designates what method was used by the user to verify their\r\n * identity and at what time.\r\n *\r\n * @see {@link GoTrueMFAApi#getAuthenticatorAssuranceLevel}.\r\n */\r\nexport interface AMREntry {\r\n  /** Authentication method name. */\r\n  method: 'password' | 'otp' | 'oauth' | 'mfa/totp' | (string & {})\r\n\r\n  /**\r\n   * Timestamp when the method was successfully used. Represents number of\r\n   * seconds since 1st January 1970 (UNIX epoch) in UTC.\r\n   */\r\n  timestamp: number\r\n}\r\n\r\nexport interface UserIdentity {\r\n  id: string\r\n  user_id: string\r\n  identity_data?: {\r\n    [key: string]: any\r\n  }\r\n  identity_id: string\r\n  provider: string\r\n  created_at?: string\r\n  last_sign_in_at?: string\r\n  updated_at?: string\r\n}\r\n\r\n/**\r\n * A MFA factor.\r\n *\r\n * @see {@link GoTrueMFAApi#enroll}\r\n * @see {@link GoTrueMFAApi#listFactors}\r\n * @see {@link GoTrueMFAAdminApi#listFactors}\r\n */\r\nexport interface Factor {\r\n  /** ID of the factor. */\r\n  id: string\r\n\r\n  /** Friendly name of the factor, useful to disambiguate between multiple factors. */\r\n  friendly_name?: string\r\n\r\n  /**\r\n   * Type of factor. `totp` and `phone` supported with this version\r\n   */\r\n  factor_type: 'totp' | 'phone' | (string & {})\r\n\r\n  /** Factor's status. */\r\n  status: 'verified' | 'unverified'\r\n\r\n  created_at: string\r\n  updated_at: string\r\n}\r\n\r\nexport interface UserAppMetadata {\r\n  provider?: string\r\n  [key: string]: any\r\n}\r\n\r\nexport interface UserMetadata {\r\n  [key: string]: any\r\n}\r\n\r\nexport interface User {\r\n  id: string\r\n  app_metadata: UserAppMetadata\r\n  user_metadata: UserMetadata\r\n  aud: string\r\n  confirmation_sent_at?: string\r\n  recovery_sent_at?: string\r\n  email_change_sent_at?: string\r\n  new_email?: string\r\n  new_phone?: string\r\n  invited_at?: string\r\n  action_link?: string\r\n  email?: string\r\n  phone?: string\r\n  created_at: string\r\n  confirmed_at?: string\r\n  email_confirmed_at?: string\r\n  phone_confirmed_at?: string\r\n  last_sign_in_at?: string\r\n  role?: string\r\n  updated_at?: string\r\n  identities?: UserIdentity[]\r\n  is_anonymous?: boolean\r\n  is_sso_user?: boolean\r\n  factors?: Factor[]\r\n}\r\n\r\nexport interface UserAttributes {\r\n  /**\r\n   * The user's email.\r\n   */\r\n  email?: string\r\n\r\n  /**\r\n   * The user's phone.\r\n   */\r\n  phone?: string\r\n\r\n  /**\r\n   * The user's password.\r\n   */\r\n  password?: string\r\n\r\n  /**\r\n   * The nonce sent for reauthentication if the user's password is to be updated.\r\n   *\r\n   * Call reauthenticate() to obtain the nonce first.\r\n   */\r\n  nonce?: string\r\n\r\n  /**\r\n   * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n   *\r\n   * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n   *\r\n   */\r\n  data?: object\r\n}\r\n\r\nexport interface AdminUserAttributes extends Omit<UserAttributes, 'data'> {\r\n  /**\r\n   * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n   *\r\n   *\r\n   * The `user_metadata` should be a JSON object that includes user-specific info, such as their first and last name.\r\n   *\r\n   * Note: When using the GoTrueAdminApi and wanting to modify a user's metadata,\r\n   * this attribute is used instead of UserAttributes data.\r\n   *\r\n   */\r\n  user_metadata?: object\r\n\r\n  /**\r\n   * A custom data object to store the user's application specific metadata. This maps to the `auth.users.app_metadata` column.\r\n   *\r\n   * Only a service role can modify.\r\n   *\r\n   * The `app_metadata` should be a JSON object that includes app-specific info, such as identity providers, roles, and other\r\n   * access control information.\r\n   */\r\n  app_metadata?: object\r\n\r\n  /**\r\n   * Confirms the user's email address if set to true.\r\n   *\r\n   * Only a service role can modify.\r\n   */\r\n  email_confirm?: boolean\r\n\r\n  /**\r\n   * Confirms the user's phone number if set to true.\r\n   *\r\n   * Only a service role can modify.\r\n   */\r\n  phone_confirm?: boolean\r\n\r\n  /**\r\n   * Determines how long a user is banned for.\r\n   *\r\n   * The format for the ban duration follows a strict sequence of decimal numbers with a unit suffix.\r\n   * Valid time units are \"ns\", \"us\" (or \"Âµs\"), \"ms\", \"s\", \"m\", \"h\".\r\n   *\r\n   * For example, some possible durations include: '300ms', '2h45m'.\r\n   *\r\n   * Setting the ban duration to 'none' lifts the ban on the user.\r\n   */\r\n  ban_duration?: string | 'none'\r\n\r\n  /**\r\n   * The `role` claim set in the user's access token JWT.\r\n   *\r\n   * When a user signs up, this role is set to `authenticated` by default. You should only modify the `role` if you need to provision several levels of admin access that have different permissions on individual columns in your database.\r\n   *\r\n   * Setting this role to `service_role` is not recommended as it grants the user admin privileges.\r\n   */\r\n  role?: string\r\n\r\n  /**\r\n   * The `password_hash` for the user's password.\r\n   *\r\n   * Allows you to specify a password hash for the user. This is useful for migrating a user's password hash from another service.\r\n   *\r\n   * Supports bcrypt, scrypt (firebase), and argon2 password hashes.\r\n   */\r\n  password_hash?: string\r\n\r\n  /**\r\n   * The `id` for the user.\r\n   *\r\n   * Allows you to overwrite the default `id` set for the user.\r\n   */\r\n  id?: string\r\n}\r\n\r\nexport interface Subscription {\r\n  /**\r\n   * The subscriber UUID. This will be set by the client.\r\n   */\r\n  id: string\r\n  /**\r\n   * The function to call every time there is an event. eg: (eventName) => {}\r\n   */\r\n  callback: (event: AuthChangeEvent, session: Session | null) => void\r\n  /**\r\n   * Call this to remove the listener.\r\n   */\r\n  unsubscribe: () => void\r\n}\r\n\r\nexport type SignInAnonymouslyCredentials = {\r\n  options?: {\r\n    /**\r\n     * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n     *\r\n     * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n     */\r\n    data?: object\r\n    /** Verification token received when the user completes the captcha on the site. */\r\n    captchaToken?: string\r\n  }\r\n}\r\n\r\nexport type SignUpWithPasswordCredentials =\r\n  | {\r\n      /** The user's email address. */\r\n      email: string\r\n      /** The user's password. */\r\n      password: string\r\n      options?: {\r\n        /** The redirect url embedded in the email link */\r\n        emailRedirectTo?: string\r\n        /**\r\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n         *\r\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n         */\r\n        data?: object\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n  | {\r\n      /** The user's phone number. */\r\n      phone: string\r\n      /** The user's password. */\r\n      password: string\r\n      options?: {\r\n        /**\r\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n         *\r\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n         */\r\n        data?: object\r\n        /** Verification token received when the user completes the captcha on the site. Requires a configured WhatsApp sender on Twilio */\r\n        captchaToken?: string\r\n        /** Messaging channel to use (e.g. whatsapp or sms) */\r\n        channel?: 'sms' | 'whatsapp'\r\n      }\r\n    }\r\nexport type SignInWithPasswordCredentials =\r\n  | {\r\n      /** The user's email address. */\r\n      email: string\r\n      /** The user's password. */\r\n      password: string\r\n      options?: {\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n  | {\r\n      /** The user's phone number. */\r\n      phone: string\r\n      /** The user's password. */\r\n      password: string\r\n      options?: {\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n\r\nexport type SignInWithPasswordlessCredentials =\r\n  | {\r\n      /** The user's email address. */\r\n      email: string\r\n      options?: {\r\n        /** The redirect url embedded in the email link */\r\n        emailRedirectTo?: string\r\n        /** If set to false, this method will not create a new user. Defaults to true. */\r\n        shouldCreateUser?: boolean\r\n        /**\r\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n         *\r\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n         */\r\n        data?: object\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n  | {\r\n      /** The user's phone number. */\r\n      phone: string\r\n      options?: {\r\n        /** If set to false, this method will not create a new user. Defaults to true. */\r\n        shouldCreateUser?: boolean\r\n        /**\r\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n         *\r\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n         */\r\n        data?: object\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n        /** Messaging channel to use (e.g. whatsapp or sms) */\r\n        channel?: 'sms' | 'whatsapp'\r\n      }\r\n    }\r\n\r\nexport type AuthFlowType = 'implicit' | 'pkce'\r\nexport type SignInWithOAuthCredentials = {\r\n  /** One of the providers supported by GoTrue. */\r\n  provider: Provider\r\n  options?: {\r\n    /** A URL to send the user to after they are confirmed. */\r\n    redirectTo?: string\r\n    /** A space-separated list of scopes granted to the OAuth application. */\r\n    scopes?: string\r\n    /** An object of query params */\r\n    queryParams?: { [key: string]: string }\r\n    /** If set to true does not immediately redirect the current browser context to visit the OAuth authorization page for the provider. */\r\n    skipBrowserRedirect?: boolean\r\n  }\r\n}\r\n\r\nexport type SignInWithIdTokenCredentials = {\r\n  /** Provider name or OIDC `iss` value identifying which provider should be used to verify the provided token. Supported names: `google`, `apple`, `azure`, `facebook`, `kakao`, `keycloak` (deprecated). */\r\n  provider: 'google' | 'apple' | 'azure' | 'facebook' | 'kakao' | (string & {})\r\n  /** OIDC ID token issued by the specified provider. The `iss` claim in the ID token must match the supplied provider. Some ID tokens contain an `at_hash` which require that you provide an `access_token` value to be accepted properly. If the token contains a `nonce` claim you must supply the nonce used to obtain the ID token. */\r\n  token: string\r\n  /** If the ID token contains an `at_hash` claim, then the hash of this value is compared to the value in the ID token. */\r\n  access_token?: string\r\n  /** If the ID token contains a `nonce` claim, then the hash of this value is compared to the value in the ID token. */\r\n  nonce?: string\r\n  options?: {\r\n    /** Verification token received when the user completes the captcha on the site. */\r\n    captchaToken?: string\r\n  }\r\n}\r\n\r\nexport type VerifyOtpParams = VerifyMobileOtpParams | VerifyEmailOtpParams | VerifyTokenHashParams\r\nexport interface VerifyMobileOtpParams {\r\n  /** The user's phone number. */\r\n  phone: string\r\n  /** The otp sent to the user's phone number. */\r\n  token: string\r\n  /** The user's verification type. */\r\n  type: MobileOtpType\r\n  options?: {\r\n    /** A URL to send the user to after they are confirmed. */\r\n    redirectTo?: string\r\n\r\n    /**\r\n     * Verification token received when the user completes the captcha on the site.\r\n     *\r\n     * @deprecated\r\n     */\r\n    captchaToken?: string\r\n  }\r\n}\r\nexport interface VerifyEmailOtpParams {\r\n  /** The user's email address. */\r\n  email: string\r\n  /** The otp sent to the user's email address. */\r\n  token: string\r\n  /** The user's verification type. */\r\n  type: EmailOtpType\r\n  options?: {\r\n    /** A URL to send the user to after they are confirmed. */\r\n    redirectTo?: string\r\n\r\n    /** Verification token received when the user completes the captcha on the site.\r\n     *\r\n     * @deprecated\r\n     */\r\n    captchaToken?: string\r\n  }\r\n}\r\n\r\nexport interface VerifyTokenHashParams {\r\n  /** The token hash used in an email link */\r\n  token_hash: string\r\n\r\n  /** The user's verification type. */\r\n  type: EmailOtpType\r\n}\r\n\r\nexport type MobileOtpType = 'sms' | 'phone_change'\r\nexport type EmailOtpType = 'signup' | 'invite' | 'magiclink' | 'recovery' | 'email_change' | 'email'\r\n\r\nexport type ResendParams =\r\n  | {\r\n      type: Extract<EmailOtpType, 'signup' | 'email_change'>\r\n      email: string\r\n      options?: {\r\n        /** A URL to send the user to after they have signed-in. */\r\n        emailRedirectTo?: string\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n  | {\r\n      type: Extract<MobileOtpType, 'sms' | 'phone_change'>\r\n      phone: string\r\n      options?: {\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n\r\nexport type SignInWithSSO =\r\n  | {\r\n      /** UUID of the SSO provider to invoke single-sign on to. */\r\n      providerId: string\r\n\r\n      options?: {\r\n        /** A URL to send the user to after they have signed-in. */\r\n        redirectTo?: string\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n  | {\r\n      /** Domain name of the organization for which to invoke single-sign on. */\r\n      domain: string\r\n\r\n      options?: {\r\n        /** A URL to send the user to after they have signed-in. */\r\n        redirectTo?: string\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n\r\nexport type GenerateSignupLinkParams = {\r\n  type: 'signup'\r\n  email: string\r\n  password: string\r\n  options?: Pick<GenerateLinkOptions, 'data' | 'redirectTo'>\r\n}\r\n\r\nexport type GenerateInviteOrMagiclinkParams = {\r\n  type: 'invite' | 'magiclink'\r\n  /** The user's email */\r\n  email: string\r\n  options?: Pick<GenerateLinkOptions, 'data' | 'redirectTo'>\r\n}\r\n\r\nexport type GenerateRecoveryLinkParams = {\r\n  type: 'recovery'\r\n  /** The user's email */\r\n  email: string\r\n  options?: Pick<GenerateLinkOptions, 'redirectTo'>\r\n}\r\n\r\nexport type GenerateEmailChangeLinkParams = {\r\n  type: 'email_change_current' | 'email_change_new'\r\n  /** The user's email */\r\n  email: string\r\n  /**\r\n   * The user's new email. Only required if type is 'email_change_current' or 'email_change_new'.\r\n   */\r\n  newEmail: string\r\n  options?: Pick<GenerateLinkOptions, 'redirectTo'>\r\n}\r\n\r\nexport interface GenerateLinkOptions {\r\n  /**\r\n   * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n   *\r\n   * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n   */\r\n  data?: object\r\n  /** The URL which will be appended to the email link generated. */\r\n  redirectTo?: string\r\n}\r\n\r\nexport type GenerateLinkParams =\r\n  | GenerateSignupLinkParams\r\n  | GenerateInviteOrMagiclinkParams\r\n  | GenerateRecoveryLinkParams\r\n  | GenerateEmailChangeLinkParams\r\n\r\nexport type GenerateLinkResponse =\r\n  | {\r\n      data: {\r\n        properties: GenerateLinkProperties\r\n        user: User\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: {\r\n        properties: null\r\n        user: null\r\n      }\r\n      error: AuthError\r\n    }\r\n\r\n/** The properties related to the email link generated  */\r\nexport type GenerateLinkProperties = {\r\n  /**\r\n   * The email link to send to the user.\r\n   * The action_link follows the following format: auth/v1/verify?type={verification_type}&token={hashed_token}&redirect_to={redirect_to}\r\n   * */\r\n  action_link: string\r\n  /**\r\n   * The raw email OTP.\r\n   * You should send this in the email if you want your users to verify using an OTP instead of the action link.\r\n   * */\r\n  email_otp: string\r\n  /**\r\n   * The hashed token appended to the action link.\r\n   * */\r\n  hashed_token: string\r\n  /** The URL appended to the action link. */\r\n  redirect_to: string\r\n  /** The verification type that the email link is associated to. */\r\n  verification_type: GenerateLinkType\r\n}\r\n\r\nexport type GenerateLinkType =\r\n  | 'signup'\r\n  | 'invite'\r\n  | 'magiclink'\r\n  | 'recovery'\r\n  | 'email_change_current'\r\n  | 'email_change_new'\r\n\r\nexport type MFAEnrollParams = MFAEnrollTOTPParams | MFAEnrollPhoneParams\r\n\r\nexport type MFAUnenrollParams = {\r\n  /** ID of the factor being unenrolled. */\r\n  factorId: string\r\n}\r\n\r\nexport type MFAVerifyParams = {\r\n  /** ID of the factor being verified. Returned in enroll(). */\r\n  factorId: string\r\n\r\n  /** ID of the challenge being verified. Returned in challenge(). */\r\n  challengeId: string\r\n\r\n  /** Verification code provided by the user. */\r\n  code: string\r\n}\r\n\r\nexport type MFAChallengeParams = {\r\n  /** ID of the factor to be challenged. Returned in enroll(). */\r\n  factorId: string\r\n  /** Messaging channel to use (e.g. whatsapp or sms). Only relevant for phone factors */\r\n  channel?: 'sms' | 'whatsapp'\r\n}\r\n\r\nexport type MFAChallengeAndVerifyParams = {\r\n  /** ID of the factor being verified. Returned in enroll(). */\r\n  factorId: string\r\n  /** Verification code provided by the user. */\r\n  code: string\r\n}\r\n\r\nexport type AuthMFAVerifyResponse =\r\n  | {\r\n      data: {\r\n        /** New access token (JWT) after successful verification. */\r\n        access_token: string\r\n\r\n        /** Type of token, typically `Bearer`. */\r\n        token_type: string\r\n\r\n        /** Number of seconds in which the access token will expire. */\r\n        expires_in: number\r\n\r\n        /** Refresh token you can use to obtain new access tokens when expired. */\r\n        refresh_token: string\r\n\r\n        /** Updated user profile. */\r\n        user: User\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: null\r\n      error: AuthError\r\n    }\r\n\r\nexport type AuthMFAEnrollResponse = AuthMFAEnrollTOTPResponse | AuthMFAEnrollPhoneResponse\r\n\r\nexport type AuthMFAUnenrollResponse =\r\n  | {\r\n      data: {\r\n        /** ID of the factor that was successfully unenrolled. */\r\n        id: string\r\n      }\r\n      error: null\r\n    }\r\n  | { data: null; error: AuthError }\r\n\r\nexport type AuthMFAChallengeResponse =\r\n  | {\r\n      data: {\r\n        /** ID of the newly created challenge. */\r\n        id: string\r\n\r\n        /** Factor Type which generated the challenge */\r\n        type: 'totp' | 'phone'\r\n\r\n        /** Timestamp in UNIX seconds when this challenge will no longer be usable. */\r\n        expires_at: number\r\n      }\r\n      error: null\r\n    }\r\n  | { data: null; error: AuthError }\r\n\r\nexport type AuthMFAListFactorsResponse =\r\n  | {\r\n      data: {\r\n        /** All available factors (verified and unverified). */\r\n        all: Factor[]\r\n\r\n        /** Only verified TOTP factors. (A subset of `all`.) */\r\n        totp: Factor[]\r\n        /** Only verified Phone factors. (A subset of `all`.) */\r\n        phone: Factor[]\r\n      }\r\n      error: null\r\n    }\r\n  | { data: null; error: AuthError }\r\n\r\nexport type AuthenticatorAssuranceLevels = 'aal1' | 'aal2'\r\n\r\nexport type AuthMFAGetAuthenticatorAssuranceLevelResponse =\r\n  | {\r\n      data: {\r\n        /** Current AAL level of the session. */\r\n        currentLevel: AuthenticatorAssuranceLevels | null\r\n\r\n        /**\r\n         * Next possible AAL level for the session. If the next level is higher\r\n         * than the current one, the user should go through MFA.\r\n         *\r\n         * @see {@link GoTrueMFAApi#challenge}\r\n         */\r\n        nextLevel: AuthenticatorAssuranceLevels | null\r\n\r\n        /**\r\n         * A list of all authentication methods attached to this session. Use\r\n         * the information here to detect the last time a user verified a\r\n         * factor, for example if implementing a step-up scenario.\r\n         */\r\n        currentAuthenticationMethods: AMREntry[]\r\n      }\r\n      error: null\r\n    }\r\n  | { data: null; error: AuthError }\r\n\r\n/**\r\n * Contains the full multi-factor authentication API.\r\n *\r\n */\r\nexport interface GoTrueMFAApi {\r\n  /**\r\n   * Starts the enrollment process for a new Multi-Factor Authentication (MFA)\r\n   * factor. This method creates a new `unverified` factor.\r\n   * To verify a factor, present the QR code or secret to the user and ask them to add it to their\r\n   * authenticator app.\r\n   * The user has to enter the code from their authenticator app to verify it.\r\n   *\r\n   * Upon verifying a factor, all other sessions are logged out and the current session's authenticator level is promoted to `aal2`.\r\n   *\r\n   */\r\n  enroll(params: MFAEnrollTOTPParams): Promise<AuthMFAEnrollTOTPResponse>\r\n  enroll(params: MFAEnrollPhoneParams): Promise<AuthMFAEnrollPhoneResponse>\r\n  enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse>\r\n\r\n  /**\r\n   * Prepares a challenge used to verify that a user has access to a MFA\r\n   * factor.\r\n   */\r\n  challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse>\r\n\r\n  /**\r\n   * Verifies a code against a challenge. The verification code is\r\n   * provided by the user by entering a code seen in their authenticator app.\r\n   */\r\n  verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse>\r\n\r\n  /**\r\n   * Unenroll removes a MFA factor.\r\n   * A user has to have an `aal2` authenticator level in order to unenroll a `verified` factor.\r\n   */\r\n  unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse>\r\n\r\n  /**\r\n   * Helper method which creates a challenge and immediately uses the given code to verify against it thereafter. The verification code is\r\n   * provided by the user by entering a code seen in their authenticator app.\r\n   */\r\n  challengeAndVerify(params: MFAChallengeAndVerifyParams): Promise<AuthMFAVerifyResponse>\r\n\r\n  /**\r\n   * Returns the list of MFA factors enabled for this user.\r\n   *\r\n   * @see {@link GoTrueMFAApi#enroll}\r\n   * @see {@link GoTrueMFAApi#getAuthenticatorAssuranceLevel}\r\n   * @see {@link GoTrueClient#getUser}\r\n   *\r\n   */\r\n  listFactors(): Promise<AuthMFAListFactorsResponse>\r\n\r\n  /**\r\n   * Returns the Authenticator Assurance Level (AAL) for the active session.\r\n   *\r\n   * - `aal1` (or `null`) means that the user's identity has been verified only\r\n   * with a conventional login (email+password, OTP, magic link, social login,\r\n   * etc.).\r\n   * - `aal2` means that the user's identity has been verified both with a conventional login and at least one MFA factor.\r\n   *\r\n   * Although this method returns a promise, it's fairly quick (microseconds)\r\n   * and rarely uses the network. You can use this to check whether the current\r\n   * user needs to be shown a screen to verify their MFA factors.\r\n   *\r\n   */\r\n  getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse>\r\n}\r\n\r\n/**\r\n * @expermental\r\n */\r\nexport type AuthMFAAdminDeleteFactorResponse =\r\n  | {\r\n      data: {\r\n        /** ID of the factor that was successfully deleted. */\r\n        id: string\r\n      }\r\n      error: null\r\n    }\r\n  | { data: null; error: AuthError }\r\n\r\n/**\r\n * @expermental\r\n */\r\nexport type AuthMFAAdminDeleteFactorParams = {\r\n  /** ID of the MFA factor to delete. */\r\n  id: string\r\n\r\n  /** ID of the user whose factor is being deleted. */\r\n  userId: string\r\n}\r\n\r\n/**\r\n * @expermental\r\n */\r\nexport type AuthMFAAdminListFactorsResponse =\r\n  | {\r\n      data: {\r\n        /** All factors attached to the user. */\r\n        factors: Factor[]\r\n      }\r\n      error: null\r\n    }\r\n  | { data: null; error: AuthError }\r\n\r\n/**\r\n * @expermental\r\n */\r\nexport type AuthMFAAdminListFactorsParams = {\r\n  /** ID of the user. */\r\n  userId: string\r\n}\r\n\r\n/**\r\n * Contains the full multi-factor authentication administration API.\r\n *\r\n * @expermental\r\n */\r\nexport interface GoTrueAdminMFAApi {\r\n  /**\r\n   * Lists all factors associated to a user.\r\n   *\r\n   */\r\n  listFactors(params: AuthMFAAdminListFactorsParams): Promise<AuthMFAAdminListFactorsResponse>\r\n\r\n  /**\r\n   * Deletes a factor on a user. This will log the user out of all active\r\n   * sessions if the deleted factor was verified.\r\n   *\r\n   * @see {@link GoTrueMFAApi#unenroll}\r\n   *\r\n   * @expermental\r\n   */\r\n  deleteFactor(params: AuthMFAAdminDeleteFactorParams): Promise<AuthMFAAdminDeleteFactorResponse>\r\n}\r\n\r\ntype AnyFunction = (...args: any[]) => any\r\ntype MaybePromisify<T> = T | Promise<T>\r\n\r\ntype PromisifyMethods<T> = {\r\n  [K in keyof T]: T[K] extends AnyFunction\r\n    ? (...args: Parameters<T[K]>) => MaybePromisify<ReturnType<T[K]>>\r\n    : T[K]\r\n}\r\n\r\nexport type SupportedStorage = PromisifyMethods<\r\n  Pick<Storage, 'getItem' | 'setItem' | 'removeItem'>\r\n> & {\r\n  /**\r\n   * If set to `true` signals to the library that the storage medium is used\r\n   * on a server and the values may not be authentic, such as reading from\r\n   * request cookies. Implementations should not set this to true if the client\r\n   * is used on a server that reads storage information from authenticated\r\n   * sources, such as a secure database or file.\r\n   */\r\n  isServer?: boolean\r\n}\r\n\r\nexport type InitializeResult = { error: AuthError | null }\r\n\r\nexport type CallRefreshTokenResult =\r\n  | {\r\n      session: Session\r\n      error: null\r\n    }\r\n  | {\r\n      session: null\r\n      error: AuthError\r\n    }\r\n\r\nexport type Pagination = {\r\n  [key: string]: any\r\n  nextPage: number | null\r\n  lastPage: number\r\n  total: number\r\n}\r\n\r\nexport type PageParams = {\r\n  /** The page number */\r\n  page?: number\r\n  /** Number of items returned per page */\r\n  perPage?: number\r\n}\r\n\r\nexport type SignOut = {\r\n  /**\r\n   * Determines which sessions should be\r\n   * logged out. Global means all\r\n   * sessions by this account. Local\r\n   * means only this session. Others\r\n   * means all other sessions except the\r\n   * current one. When using others,\r\n   * there is no sign-out event fired on\r\n   * the current session!\r\n   */\r\n  scope?: 'global' | 'local' | 'others'\r\n}\r\n\r\nexport type MFAEnrollTOTPParams = {\r\n  /** The type of factor being enrolled. */\r\n  factorType: 'totp'\r\n  /** Domain which the user is enrolled with. */\r\n  issuer?: string\r\n  /** Human readable name assigned to the factor. */\r\n  friendlyName?: string\r\n}\r\nexport type MFAEnrollPhoneParams = {\r\n  /** The type of factor being enrolled. */\r\n  factorType: 'phone'\r\n  /** Human readable name assigned to the factor. */\r\n  friendlyName?: string\r\n  /** Phone number associated with a factor. Number should conform to E.164 format */\r\n  phone: string\r\n}\r\n\r\nexport type AuthMFAEnrollTOTPResponse =\r\n  | {\r\n      data: {\r\n        /** ID of the factor that was just enrolled (in an unverified state). */\r\n        id: string\r\n\r\n        /** Type of MFA factor.*/\r\n        type: 'totp'\r\n\r\n        /** TOTP enrollment information. */\r\n        totp: {\r\n          /** Contains a QR code encoding the authenticator URI. You can\r\n           * convert it to a URL by prepending `data:image/svg+xml;utf-8,` to\r\n           * the value. Avoid logging this value to the console. */\r\n          qr_code: string\r\n\r\n          /** The TOTP secret (also encoded in the QR code). Show this secret\r\n           * in a password-style field to the user, in case they are unable to\r\n           * scan the QR code. Avoid logging this value to the console. */\r\n          secret: string\r\n\r\n          /** The authenticator URI encoded within the QR code, should you need\r\n           * to use it. Avoid loggin this value to the console. */\r\n          uri: string\r\n        }\r\n        /** Friendly name of the factor, useful for distinguishing between factors **/\r\n        friendly_name?: string\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: null\r\n      error: AuthError\r\n    }\r\n\r\nexport type AuthMFAEnrollPhoneResponse =\r\n  | {\r\n      data: {\r\n        /** ID of the factor that was just enrolled (in an unverified state). */\r\n        id: string\r\n\r\n        /** Type of MFA factor. */\r\n        type: 'phone'\r\n\r\n        /** Friendly name of the factor, useful for distinguishing between factors **/\r\n        friendly_name?: string\r\n\r\n        /** Phone number of the MFA factor in E.164 format. Used to send messages  */\r\n        phone: string\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: null\r\n      error: AuthError\r\n    }\r\n\r\nexport type JwtHeader = {\r\n  alg: 'RS256' | 'ES256' | 'HS256'\r\n  kid: string\r\n  typ: string\r\n}\r\n\r\nexport type RequiredClaims = {\r\n  iss: string\r\n  sub: string\r\n  aud: string | string[]\r\n  exp: number\r\n  iat: number\r\n  role: string\r\n  aal: AuthenticatorAssuranceLevels\r\n  session_id: string\r\n}\r\n\r\nexport type JwtPayload = RequiredClaims & {\r\n  [key: string]: any\r\n}\r\n\r\nexport interface JWK {\r\n  kty: 'RSA' | 'EC' | 'oct'\r\n  key_ops: string[]\r\n  alg?: string\r\n  kid?: string\r\n  [key: string]: any\r\n}\r\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}